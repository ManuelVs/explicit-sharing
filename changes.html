<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml"
><head
  ><title
    >Changes w.r.t. version 0.1</title
    ><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"
     /><meta name="generator" content="pandoc"
     /><style type="text/css"
    >
table.sourceCode, tr.sourceCode, td.lineNumbers, td.sourceCode, table.sourceCode pre 
   { margin: 0; padding: 0; border: 0; vertical-align: baseline; border: none; }
td.lineNumbers { border-right: 1px solid #AAAAAA; text-align: right; color: #AAAAAA; padding-right: 5px; padding-left: 5px; }
td.sourceCode { padding-left: 5px; }
pre.sourceCode { }
pre.sourceCode span.Normal { }
pre.sourceCode span.Keyword { color: #007020; font-weight: bold; } 
pre.sourceCode span.DataType { color: #902000; }
pre.sourceCode span.DecVal { color: #40a070; }
pre.sourceCode span.BaseN { color: #40a070; }
pre.sourceCode span.Float { color: #40a070; }
pre.sourceCode span.Char { color: #4070a0; }
pre.sourceCode span.String { color: #4070a0; }
pre.sourceCode span.Comment { color: #60a0b0; font-style: italic; }
pre.sourceCode span.Others { color: #007020; }
pre.sourceCode span.Alert { color: red; font-weight: bold; }
pre.sourceCode span.Function { color: #06287e; }
pre.sourceCode span.RegionMarker { }
pre.sourceCode span.Error { color: red; font-weight: bold; }
</style
    ><link rel="stylesheet" href="lhs.css" type="text/css" media="all" />
</head
  ><body
  ><h1 class="title"
    >Changes w.r.t. version 0.1</h1
    ><div id="toc"
    ><ul
      ><li
	><a href="#converting-nested-monadic-data" id="TOC-converting-nested-monadic-data"
	  >converting nested monadic data</a
	  ></li
	><li
	><a href="#Nondet-is-now-Shareable" id="TOC-Nondet-is-now-Shareable"
	  ><code
	    >Nondet</code
	    > is now <code
	    >Shareable</code
	    ></a
	  ></li
	><li
	><a href="#alternative-implementation" id="TOC-alternative-implementation"
	  >alternative implementation</a
	  ></li
	></ul
      ></div
    ><p
    >The interface of the <a href="index.html"
      >library for explicit sharing</a
      > has changed since the first version to incorporate an alternative implementation and support conversion between nested monadic data and ordinary Haskell types.</p
    ><h2 id="converting-nested-monadic-data"
    ><a href="#TOC-converting-nested-monadic-data"
      >converting nested monadic data</a
      ></h2
    ><p
    >The is now a type class <code
      >Convertible</code
      > defined as follows.</p
    ><pre class="sourceCode Haskell"
    ><code
      ><span class="Keyword"
	>class</span
	><span class="Normal NormalText"
	> Convertible m a b</span
	><br
	 /><span class="Normal NormalText"
	> </span
	><span class="Keyword"
	>where</span
	><br
	 /><span class="Normal NormalText"
	>  </span
	><span class="Function FunctionDefinition"
	>convArgs ::</span
	><span class="Normal NormalText"
	> (forall c d . Convertible m c d =&gt; c -&gt; m d) -&gt; a -&gt; m b</span
	><br
	 /></code
      ></pre
    ><p
    >This type class supports converting back and forth between nested monadic data and isomorphic ordinary Haskell data. You can find example instances for monadic lists in the <a href="tutorial.html#nested-monadic-data"
      >tutorial</a
      >.</p
    ><h2 id="Nondet-is-now-Shareable"
    ><a href="#TOC-Nondet-is-now-Shareable"
      ><code
	>Nondet</code
	> is now <code
	>Shareable</code
	></a
      ></h2
    ><p
    >The type class <code
      >Nondet</code
      > has been replaced by a generalized type class <code
      >Shareable</code
      > that allows the monad which is used for the transformation of arguments to be different from the monad that wraps nested arguments. Instead of the operation</p
    ><pre class="sourceCode Haskell"
    ><code
      ><span class="Function FunctionDefinition"
	>mapNondet ::</span
	><span class="Normal NormalText"
	> (forall b . Nondet m b =&gt; m b -&gt; m (m b)) -&gt; a -&gt; m a</span
	><br
	 /></code
      ></pre
    ><p
    >the class <code
      >Shareable</code
      > defines the following operation.</p
    ><pre class="sourceCode Haskell"
    ><code
      ><span class="Function FunctionDefinition"
	>shareArgs ::</span
	><span class="Normal NormalText"
	> </span
	><span class="Keyword Class"
	>Monad</span
	><span class="Normal NormalText"
	> n =&gt; (forall b . Shareable m b =&gt; m b -&gt; n (m b)) -&gt; a -&gt; n a</span
	><br
	 /></code
      ></pre
    ><p
    >This generalization allows to use a state monad when sharing arguments even if no state monad is used to represent monadic arguments and was necessary to implement the alternative approach to explicit sharing.</p
    ><h2 id="alternative-implementation"
    ><a href="#TOC-alternative-implementation"
      >alternative implementation</a
      ></h2
    ><p
    >There is an experimental version of an alternative implementation available via the module <code
      >Control.Monad.Sharing.FirstOrder</code
      >. It represents monadic actions as first order data types instead of state-passing functions and, hence, supports (some) sharing across non-determinism.</p
    ><p
    >This implementation is not (yet) as efficient as the continuation-based default implementation, so you should usually use the original version and only resort to the new one, if your program benefits considerably from sharing across non-determinism as provided by the new implementation.</p
    ><p
    >An example program that benefits from sharing across non-determinism is the following:</p
    ><pre class="sourceCode haskell"
    ><code
      ><span class="Keyword"
	>import</span
	><span class="Normal NormalText"
	> </span
	><span class="Normal ModuleName"
	>Control.Monad.Sharing.FirstOrder</span
	><br
	 /><span class="Keyword"
	>import</span
	><span class="Normal NormalText"
	> </span
	><span class="Normal ModuleName"
	>Data.Monadic.List</span
	><br
	 /><br
	 /><span class="Keyword"
	>import</span
	><span class="Normal NormalText"
	> Prelude hiding ( </span
	><span class="Function"
	>last</span
	><span class="Normal NormalText"
	> )</span
	><br
	 /><br
	 /><span class="Function FunctionDefinition"
	>listOf ::</span
	><span class="Normal NormalText"
	> (MonadPlus m, Sharing m, Shareable m a) =&gt; m a -&gt; m (List m a)</span
	><br
	 /><span class="Normal NormalText"
	>listOf x = nil</span
	><br
	 /><span class="Normal NormalText"
	>   </span
	><span class="Others InfixOperator"
	>`mplus`</span
	><span class="Normal NormalText"
	> </span
	><span class="Keyword"
	>do</span
	><span class="Normal NormalText"
	> y &lt;- share x</span
	><br
	 /><span class="Normal NormalText"
	>              cons y (listOf y)</span
	><br
	 /></code
      ></pre
    ><p
    >The function <code
      >listOf</code
      > non-deterministically yields a list of arbitrary length that only contains the given element (which may itself be non-deterministic).</p
    ><p
    >If we apply <code
      >listOf</code
      > to an expensive computation this computation would be reexecuted on every non-deterministic branch on which it is demanded. This behaviour resembles the behaviour of the Curry systems <a href="http://www.informatik.uni-kiel.de/~pakcs/"
      >PAKCS</a
      > and <a href="http://danae.uni-muenster.de/~lux/curry/"
      >MCC</a
      >. If we use the alternative implementation of explicit sharing the expensive computation is only executed once if its result is a first-order value which is the case in this example, if the underlying monad is, e.g., the list monad. This behaviour resembles the behaviour of the Curry system <a href="http://www.informatik.uni-kiel.de/prog/mitarbeiter/bernd-brassel/projects/"
      >KiCS</a
      >.</p
    ><p
    >We can observe the difference by applying the <code
      >last</code
      > function to the result of <code
      >listOf</code
      >.</p
    ><pre class="sourceCode haskell"
    ><code
      ><span class="Function"
	>last</span
	><span class="Normal NormalText"
	> :: (MonadPlus m, Sharing m, Shareable m a) =&gt; List m a -&gt; m a</span
	><br
	 /><span class="Function"
	>last</span
	><span class="Normal NormalText"
	> Nil           = mzero</span
	><br
	 /><span class="Function"
	>last</span
	><span class="Normal NormalText"
	> (Cons mx mxs) = </span
	><span class="Keyword"
	>do</span
	><span class="Normal NormalText"
	> mys &lt;- share mxs</span
	><br
	 /><span class="Normal NormalText"
	>                        ys &lt;- mys</span
	><br
	 /><span class="Normal NormalText"
	>                        </span
	><span class="Keyword"
	>case</span
	><span class="Normal NormalText"
	> ys </span
	><span class="Keyword"
	>of</span
	><br
	 /><span class="Normal NormalText"
	>                          Nil         -&gt; mx </span
	><br
	 /><span class="Normal NormalText"
	>                          Cons mz mzs -&gt; </span
	><span class="Function"
	>last</span
	><span class="Normal NormalText"
	> =&lt;&lt; mys</span
	><br
	 /></code
      ></pre
    ><p
    >As expensive computation we use the recursive implementation of the Fibonacci function in monadic style.</p
    ><pre class="sourceCode haskell"
    ><code
      ><span class="Function FunctionDefinition"
	>fib ::</span
	><span class="Normal NormalText"
	> </span
	><span class="Keyword Class"
	>Monad</span
	><span class="Normal NormalText"
	> m =&gt; </span
	><span class="DataType TypeConstructor"
	>Int</span
	><span class="Normal NormalText"
	> -&gt; m </span
	><span class="DataType TypeConstructor"
	>Int</span
	><br
	 /><span class="Normal NormalText"
	>fib n | n &lt; </span
	><span class="DecVal Decimal"
	>2</span
	><span class="Normal NormalText"
	>     = </span
	><span class="Function"
	>return</span
	><span class="Normal NormalText"
	> n</span
	><br
	 /><span class="Normal NormalText"
	>      | </span
	><span class="Function"
	>otherwise</span
	><span class="Normal NormalText"
	> = liftM2 (+) (fib (n</span
	><span class="DecVal Decimal"
	>-2</span
	><span class="Normal NormalText"
	>)) (fib (n</span
	><span class="DecVal Decimal"
	>-1</span
	><span class="Normal NormalText"
	>))</span
	><br
	 /></code
      ></pre
    ><p
    >If we now query some solutions of the following computation</p
    ><pre
    ><code
      > &gt; mapM_ print $ take 5 (evalLazy (last =&lt;&lt; listOf (fib 30)) :: [Int])
 832040
 832040
 832040
 832040
 832040
</code
      ></pre
    ><p
    >The solutions are printed slowly one after the other if we use the default implementation of explicit sharing and almost simultaneously if we use the alternative version. The default version recomputes <code
      >fib 30</code
      > the alternative version does not.</p
    ></body
  ></html
>

