<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml"
><head
  ><title
    >how to use explicit sharing</title
    ><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"
     /><meta name="generator" content="pandoc"
     /><style type="text/css"
    >
table.sourceCode, tr.sourceCode, td.lineNumbers, td.sourceCode, table.sourceCode pre 
   { margin: 0; padding: 0; border: 0; vertical-align: baseline; border: none; }
td.lineNumbers { border-right: 1px solid #AAAAAA; text-align: right; color: #AAAAAA; padding-right: 5px; padding-left: 5px; }
td.sourceCode { padding-left: 5px; }
pre.sourceCode { }
pre.sourceCode span.Normal { }
pre.sourceCode span.Keyword { color: #007020; font-weight: bold; } 
pre.sourceCode span.DataType { color: #902000; }
pre.sourceCode span.DecVal { color: #40a070; }
pre.sourceCode span.BaseN { color: #40a070; }
pre.sourceCode span.Float { color: #40a070; }
pre.sourceCode span.Char { color: #4070a0; }
pre.sourceCode span.String { color: #4070a0; }
pre.sourceCode span.Comment { color: #60a0b0; font-style: italic; }
pre.sourceCode span.Others { color: #007020; }
pre.sourceCode span.Alert { color: red; font-weight: bold; }
pre.sourceCode span.Function { color: #06287e; }
pre.sourceCode span.RegionMarker { }
pre.sourceCode span.Error { color: red; font-weight: bold; }
</style
    ><link rel="stylesheet" href="lhs.css" type="text/css" media="all" />
</head
  ><body
  ><h1 class="title"
    >how to use explicit sharing</h1
    ><div id="toc"
    ><ul
      ><li
	><a href="#sharing-io-effects" id="TOC-sharing-io-effects"
	  >sharing IO effects</a
	  ></li
	><li
	><a href="#nested-monadic-data" id="TOC-nested-monadic-data"
	  >nested monadic data</a
	  ></li
	><li
	><a href="#outlook" id="TOC-outlook"
	  >outlook</a
	  ></li
	></ul
      ></div
    ><div class="nodisplay">
<pre class="sourceCode haskell"
    ><code
      ><span class="Comment"
	>{-# LANGUAGE PackageImports #-}</span
	><br
	 /><span class="Keyword"
	>import</span
	><span class="Normal NormalText"
	> </span
	><span class="String"
	>&quot;mtl&quot;</span
	><span class="Normal NormalText"
	> </span
	><span class="Normal ModuleName"
	>Control.Monad.Trans</span
	><br
	 /><span class="Keyword"
	>import</span
	><span class="Normal NormalText"
	> </span
	><span class="Normal ModuleName"
	>Data.Monadic.List</span
	><br
	 /></code
      ></pre
    ></div>
<p
    >This <a href="tutorial.lhs"
      >literate program</a
      > explains how to use the <a href="index.html"
      >explicit-sharing</a
      > package which provides the following module.</p
    ><pre class="sourceCode haskell"
    ><code
      ><span class="Keyword"
	>import</span
	><span class="Normal NormalText"
	> </span
	><span class="Normal ModuleName"
	>Control.Monad.Sharing</span
	><br
	 /></code
      ></pre
    ><p
    >The interface of this module basically consists of two type classes. Instances of <code
      >Sharing</code
      > support a combinator <code
      >share</code
      > for explicit sharing and are usually monads. If you fell like you don't know enough about monads you may want to look at the <a href="http://www.haskell.org/sitewiki/images/8/85/TMR-Issue13.pdf"
      >Typeclassopedia</a
      >.</p
    ><pre class="sourceCode Haskell"
    ><code
      ><span class="Keyword"
	>class</span
	><span class="Normal NormalText"
	> Sharing m</span
	><br
	 /><span class="Normal NormalText"
	> </span
	><span class="Keyword"
	>where</span
	><br
	 /><span class="Normal NormalText"
	>  </span
	><span class="Function FunctionDefinition"
	>share ::</span
	><span class="Normal NormalText"
	> Shareable m a =&gt; m a -&gt; m (m a)</span
	><br
	 /></code
      ></pre
    ><p
    >The type class <code
      >Shareable</code
      > is an interface to data that can be shared explicitly.</p
    ><p
    >The function <code
      >share</code
      > takes a monadic action of type <code
      >m a</code
      > and yields an action in the same monad which yields a monadic action of the same type as the argument. The idea is that <code
      >share</code
      > yields something like the original action which can be duplicated without duplicating the effects.</p
    ><h2 id="sharing-io-effects"
    ><a href="#TOC-sharing-io-effects"
      >sharing IO effects</a
      ></h2
    ><p
    >Let's look at an example. First consider a program that does not use explicit sharing.</p
    ><pre class="sourceCode haskell"
    ><code
      ><span class="Function FunctionDefinition"
	>dup_get ::</span
	><span class="Normal NormalText"
	> </span
	><span class="DataType TypeConstructor"
	>IO</span
	><span class="Normal NormalText"
	> </span
	><span class="DataType TypeConstructor"
	>String</span
	><br
	 /><span class="Normal NormalText"
	>dup_get = </span
	><span class="Keyword"
	>do</span
	><span class="Normal NormalText"
	> </span
	><span class="Keyword"
	>let</span
	><span class="Normal NormalText"
	> get = </span
	><span class="Function"
	>getChar</span
	><br
	 /><span class="Normal NormalText"
	>             a &lt;- get</span
	><br
	 /><span class="Normal NormalText"
	>             b &lt;- get</span
	><br
	 /><span class="Normal NormalText"
	>             c &lt;- get</span
	><br
	 /><span class="Normal NormalText"
	>             </span
	><span class="Function"
	>return</span
	><span class="Normal NormalText"
	> [a,b,c]</span
	><br
	 /></code
      ></pre
    ><p
    >This action renames the predefined action <code
      >getChar</code
      > and calls it three times returning a list of the results of the three calls:</p
    ><pre
    ><code
      >*Main&gt; dup_get
xyz
&quot;xyz&quot;
</code
      ></pre
    ><p
    >Each occurrence of <code
      >get</code
      > reads a different character from standard input, i.e., has its own independent input effect and all occurrences of <code
      >get</code
      > can have different results. Haskells <code
      >let</code
      > construct shares the IO action <code
      >getChar</code
      > which can still be executed independently more than once.</p
    ><p
    >The <code
      >share</code
      > combinator provides a different kind of sharing. An IO action that is shared explicitly using <code
      >share</code
      > can still be executed multiple times but its effects are only performed on first execution and an explicitly shared action will return the same result whenever it is executed.</p
    ><p
    >Here is a variant of the above action with explicit sharing.</p
    ><pre class="sourceCode haskell"
    ><code
      ><span class="Function FunctionDefinition"
	>dup_shared_get ::</span
	><span class="Normal NormalText"
	> (MonadIO m, Sharing m) =&gt; m </span
	><span class="DataType TypeConstructor"
	>String</span
	><br
	 /><span class="Normal NormalText"
	>dup_shared_get = </span
	><span class="Keyword"
	>do</span
	><span class="Normal NormalText"
	> get &lt;- share (liftIO </span
	><span class="Function"
	>getChar</span
	><span class="Normal NormalText"
	>)</span
	><br
	 /><span class="Normal NormalText"
	>                    a &lt;- get</span
	><br
	 /><span class="Normal NormalText"
	>                    b &lt;- get</span
	><br
	 /><span class="Normal NormalText"
	>                    c &lt;- get</span
	><br
	 /><span class="Normal NormalText"
	>                    </span
	><span class="Function"
	>return</span
	><span class="Normal NormalText"
	> [a,b,c]</span
	><br
	 /></code
      ></pre
    ><p
    >Instead of the built-in <code
      >let</code
      > construct this action uses the <code
      >share</code
      > combinator to share the (now lifted) <code
      >getChar</code
      > action. We need to lift the <code
      >getChar</code
      > action because we cannot execute <code
      >dup_shaed_get</code
      > directly in the IO monad which does not support the <code
      >share</code
      > combinator.</p
    ><p
    >We can run this action using the operation <code
      >evalLazy</code
      >.</p
    ><pre
    ><code
      >*Main&gt; evalLazy dup_shared_get :: IO String
xyz
&quot;xxx&quot;
</code
      ></pre
    ><p
    >This time, the result is <code
      >&quot;xxx&quot;</code
      > rather than <code
      >&quot;xyz&quot;</code
      >. The shared <code
      >get</code
      > action only performs the effects of <code
      >getChar</code
      > once and yields the result of the first execution at each duplicated occurrence. The remaining characters (<code
      >&quot;yz&quot;</code
      > in the example call above) are never read.</p
    ><p
    >This behaviour may seem as if <code
      >share</code
      > simply executes the given action and returns an action that yields the obtained result. It does not. The action given to <code
      >share</code
      > is only executed if the action that <code
      >share</code
      > returns is, i.e., <code
      >share</code
      > is lazy:</p
    ><pre class="sourceCode haskell"
    ><code
      ><span class="Function FunctionDefinition"
	>ignore_shared ::</span
	><span class="Normal NormalText"
	> (MonadIO m, Sharing m) =&gt; m </span
	><span class="DataType TypeConstructor"
	>String</span
	><br
	 /><span class="Normal NormalText"
	>ignore_shared =</span
	><br
	 /><span class="Normal NormalText"
	> </span
	><span class="Keyword"
	>do</span
	><span class="Normal NormalText"
	> action &lt;- share (liftIO (</span
	><span class="Function"
	>error</span
	><span class="Normal NormalText"
	> </span
	><span class="String"
	>&quot;don't touch me!&quot;</span
	><span class="Normal NormalText"
	> :: </span
	><span class="DataType TypeConstructor"
	>IO</span
	><span class="Normal NormalText"
	> </span
	><span class="DataType TypeConstructor"
	>String</span
	><span class="Normal NormalText"
	>))</span
	><br
	 /><span class="Normal NormalText"
	>    </span
	><span class="Function"
	>return</span
	><span class="Normal NormalText"
	> </span
	><span class="String"
	>&quot;didn't touch you.&quot;</span
	><br
	 /></code
      ></pre
    ><p
    >Running <code
      >ignore_shared</code
      > yields <code
      >&quot;didn't touch you.&quot;</code
      > without touching the <code
      >error</code
      > call:</p
    ><pre
    ><code
      >*Main&gt; evalLazy ignore_shared :: IO String
&quot;didn't touch you.&quot;
</code
      ></pre
    ><h2 id="nested-monadic-data"
    ><a href="#TOC-nested-monadic-data"
      >nested monadic data</a
      ></h2
    ><p
    >Let's return to the type class <code
      >Shareable</code
      > that specifies what data can be shared. The <code
      >share</code
      > combinator is not only applicable to predefined Haskell types like <code
      >String</code
      > but also to user-defined types that contain nested monadic components. For example, the module <code
      >Data.Monadic.List</code
      > defines a type for lists with monadic heads and tails.</p
    ><pre class="sourceCode Haskell"
    ><code
      ><span class="Keyword"
	>data</span
	><span class="Normal NormalText"
	> List m a = Nil | Cons (m a) (m (List m a))</span
	><br
	 /></code
      ></pre
    ><p
    >In order to be able to use <code
      >share</code
      > with values of this type, we need an instance of <code
      >Shareable</code
      > (which is also provided out of the box).</p
    ><pre class="sourceCode Haskell"
    ><code
      ><span class="Keyword"
	>instance</span
	><span class="Normal NormalText"
	> (</span
	><span class="Keyword Class"
	>Monad</span
	><span class="Normal NormalText"
	> m, Shareable m a) =&gt; Shareable m (List m a)</span
	><br
	 /><span class="Normal NormalText"
	> </span
	><span class="Keyword"
	>where</span
	><br
	 /><span class="Normal NormalText"
	>  shareArgs _ Nil         = </span
	><span class="Function"
	>return</span
	><span class="Normal NormalText"
	> Nil</span
	><br
	 /><span class="Normal NormalText"
	>  shareArgs f (Cons x xs) = </span
	><span class="Function"
	>return</span
	><span class="Normal NormalText"
	> Cons </span
	><span class="Others InfixOperator"
	>`ap`</span
	><span class="Normal NormalText"
	> f x </span
	><span class="Others InfixOperator"
	>`ap`</span
	><span class="Normal NormalText"
	> f xs</span
	><br
	 /></code
      ></pre
    ><p
    >The type class <code
      >Shareable</code
      > defines one operation <code
      >shareArgs</code
      > to generically traverse nested monadic types. As you can see in the above instance declaration, the given function <code
      >f</code
      > is applied to every monadic child of a compound value and the results are combined using the matched constructor.</p
    ><p
    >The <code
      >share</code
      > combinator uses this functionality to share nested monadic components of data recursively. Here is an example that shares an infinite <code
      >List</code
      > of <code
      >getChar</code
      > operations and returns a list of some of them that are duplicated.</p
    ><pre class="sourceCode haskell"
    ><code
      ><span class="Function FunctionDefinition"
	>share_list ::</span
	><span class="Normal NormalText"
	> (MonadIO m, Sharing m) =&gt; m (List m </span
	><span class="DataType TypeConstructor"
	>Char</span
	><span class="Normal NormalText"
	>)</span
	><br
	 /><span class="Normal NormalText"
	>share_list = </span
	><span class="Keyword"
	>do</span
	><span class="Normal NormalText"
	> gets &lt;- share getChars</span
	><br
	 /><span class="Normal NormalText"
	>                Cons a </span
	><span class="Keyword"
	>as</span
	><span class="Normal NormalText"
	> &lt;- gets</span
	><br
	 /><span class="Normal NormalText"
	>                Cons b bs &lt;- </span
	><span class="Keyword"
	>as</span
	><br
	 /><span class="Normal NormalText"
	>                Cons c cs &lt;- gets</span
	><br
	 /><span class="Normal NormalText"
	>                cons a (cons b (cons c (cons a (cons b (cons c nil)))))</span
	><br
	 /><span class="Normal NormalText"
	> </span
	><span class="Keyword"
	>where</span
	><br
	 /><span class="Normal NormalText"
	>  getChars = cons (liftIO </span
	><span class="Function"
	>getChar</span
	><span class="Normal NormalText"
	>) getChars</span
	><br
	 /></code
      ></pre
    ><p
    >The functions <code
      >nil</code
      > and <code
      >cons</code
      > are helper functions to construct nested monadic lists. This example is definitely contrived but it helps to make a point: the infine list <code
      >gets</code
      > is shared and hence all contained actions are shared too. Hence, <code
      >a</code
      > and <code
      >as</code
      > are the same as <code
      >c</code
      > and <code
      >cs</code
      > and all actions yield the same results when duplicated. The result of <code
      >share_list</code
      > is a list with six elements that will read two characters from the standard input when executed.</p
    ><p
    >How can we observe this list? The <code
      >List</code
      > type comes with an instance of another type class <code
      >Convertible</code
      > that allows <code
      >evalLazy</code
      > to convert <code
      >List</code
      >s to ordinary Haskell lists.</p
    ><pre class="sourceCode Haskell"
    ><code
      ><span class="Keyword"
	>instance</span
	><span class="Normal NormalText"
	> (</span
	><span class="Keyword Class"
	>Monad</span
	><span class="Normal NormalText"
	> m, Convertible m a b) =&gt; Convertible m (List m a) [b]</span
	><br
	 /><span class="Normal NormalText"
	> </span
	><span class="Keyword"
	>where</span
	><br
	 /><span class="Normal NormalText"
	>  convArgs _ Nil         = </span
	><span class="Function"
	>return</span
	><span class="Normal NormalText"
	> []</span
	><br
	 /><span class="Normal NormalText"
	>  convArgs f (Cons x xs) = </span
	><span class="Function"
	>return</span
	><span class="Normal NormalText"
	> (:) </span
	><span class="Others InfixOperator"
	>`ap`</span
	><span class="Normal NormalText"
	> (x &gt;&gt;= f) </span
	><span class="Others InfixOperator"
	>`ap`</span
	><span class="Normal NormalText"
	> join (xs &gt;&gt;= f)</span
	><br
	 /></code
      ></pre
    ><p
    >This instance lifts all nested monadic effects to the top-level such that a corresponding transformation yields an ordinary list without any nested effects.</p
    ><p
    >Now we can observe that indeed only two characters are read:</p
    ><pre
    ><code
      >*Main&gt; evalLazy share_list :: IO String
xyz
&quot;xyxxyx&quot;
</code
      ></pre
    ><p
    >In order to convert in the other direction, there is yet another instance of <code
      >Convertible</code
      > for <code
      >List</code
      >s:</p
    ><pre class="sourceCode Haskell"
    ><code
      ><span class="Keyword"
	>instance</span
	><span class="Normal NormalText"
	> (</span
	><span class="Keyword Class"
	>Monad</span
	><span class="Normal NormalText"
	> m, Convertible m a b) =&gt; Convertible m [a] (List m b)</span
	><br
	 /><span class="Normal NormalText"
	> </span
	><span class="Keyword"
	>where</span
	><br
	 /><span class="Normal NormalText"
	>  trans _ []     = </span
	><span class="Function"
	>return</span
	><span class="Normal NormalText"
	> Nil</span
	><br
	 /><span class="Normal NormalText"
	>  trans f (x:xs) = </span
	><span class="Function"
	>return</span
	><span class="Normal NormalText"
	> (Cons (f x) (f xs))</span
	><br
	 /></code
      ></pre
    ><p
    >Thanks to this instance, we can use the function</p
    ><pre class="sourceCode Haskell"
    ><code
      ><span class="Function FunctionDefinition"
	>convert ::</span
	><span class="Normal NormalText"
	> (</span
	><span class="Keyword Class"
	>Monad</span
	><span class="Normal NormalText"
	> m, Convertible m a b) =&gt; a -&gt; m b</span
	><br
	 /></code
      ></pre
    ><p
    >to convert a list of type <code
      >[Char]</code
      > into one of type <code
      >m (List m Char)</code
      >.</p
    ><h2 id="outlook"
    ><a href="#TOC-outlook"
      >outlook</a
      ></h2
    ><p
    >Now, we have seen it all: the <code
      >share</code
      > combinator from the type class <code
      >Sharing</code
      > which implements explicit sharing of monadic effects such that monadic actions can be duplicated without duplicating their effects and three different instances of the type classes <code
      >Shareable</code
      > and <code
      >Convertible</code
      > which allow nested monadic data to be shared and converted back and forth to ordinary data respectively. But what is this good for?</p
    ><p
    >A monadic effect whose interaction whith sharing is particularly interesting ins non-determinism. By combining the features for non-determinism provided by the <code
      >MonadPlus</code
      > type class with explicit sharing provided by the <code
      >Sharing</code
      > class we can implement lazy functional-logic programming as advocated, e.g., by the <a href="http://curry-language.org"
      >Curry</a
      > language in pure Haskell.</p
    ><p
    ><a href="flp.html"
      >How to translate Curry programs to Haskell using explicit sharing</a
      > is worth a different tutorial.</p
    ></body
  ></html
>

