<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml"
><head
  ><title
    >lazy FLP in pure Haskell</title
    ><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"
     /><meta name="generator" content="pandoc"
     /><style type="text/css"
    >
table.sourceCode, tr.sourceCode, td.lineNumbers, td.sourceCode, table.sourceCode pre 
   { margin: 0; padding: 0; border: 0; vertical-align: baseline; border: none; }
td.lineNumbers { border-right: 1px solid #AAAAAA; text-align: right; color: #AAAAAA; padding-right: 5px; padding-left: 5px; }
td.sourceCode { padding-left: 5px; }
pre.sourceCode { }
pre.sourceCode span.Normal { }
pre.sourceCode span.Keyword { color: #007020; font-weight: bold; } 
pre.sourceCode span.DataType { color: #902000; }
pre.sourceCode span.DecVal { color: #40a070; }
pre.sourceCode span.BaseN { color: #40a070; }
pre.sourceCode span.Float { color: #40a070; }
pre.sourceCode span.Char { color: #4070a0; }
pre.sourceCode span.String { color: #4070a0; }
pre.sourceCode span.Comment { color: #60a0b0; font-style: italic; }
pre.sourceCode span.Others { color: #007020; }
pre.sourceCode span.Alert { color: red; font-weight: bold; }
pre.sourceCode span.Function { color: #06287e; }
pre.sourceCode span.RegionMarker { }
pre.sourceCode span.Error { color: red; font-weight: bold; }
</style
    ><style type="text/css">
  body { font-family: Optima, sans-serif; width: 40em; color: dimgray; }

  h1, h2 { color: wheat; }
  h2 { margin-top: 1em; }

  p { line-height: 1.5em; }
  p code { font-weight: bold; font-size: 1.2em; }

  pre.sourceCode {
    border-left: solid lightsteelblue;
    padding-left: 1em;
  }

  a { color: midnightblue; }

  hr { border: thin solid midnightblue; }

  blockquote { font-size: 90%; font-style: italic; }

  .nodisplay { display: none; }

  #toc a { font-weight: bold; text-decoration: none; color: wheat; }

  h1 a, h2 a { text-decoration: none; color: wheat; }
</style>
</head
  ><body
  ><h1 class="title"
    >lazy FLP in pure Haskell</h1
    ><div id="toc"
    ><ul
      ><li
	><a href="#lazy-permutation-sort-in-curry" id="TOC-lazy-permutation-sort-in-curry"
	  >lazy permutation sort in Curry</a
	  ></li
	><li
	><a href="#lazy-permutation-sort-in-haskell" id="TOC-lazy-permutation-sort-in-haskell"
	  >lazy permutation sort in Haskell</a
	  ></li
	></ul
      ></div
    ><p
    >This <a href="flp.lhs"
      >literate program</a
      > explains how to express programs written in the lazy functional-logic programming language <a href="http://curry-language.org"
      >Curry</a
      > in pure Haskell using the <a href="index.html"
      >explicit-sharing</a
      > package. If you have not done so already you may want to read the <a href="tutorial.html"
      >tutorial</a
      > introduction to this package first.</p
    ><h2 id="lazy-permutation-sort-in-curry"
    ><a href="#TOC-lazy-permutation-sort-in-curry"
      >lazy permutation sort in Curry</a
      ></h2
    ><p
    >Lazy functional-logic programming is tailor made for expressing demand driven search algorithms concisely. For example, we can express sorting as a demand driven search problem in Curry as follows.</p
    ><pre class="sourceCode Haskell"
    ><code
      ><span class="Function FunctionDefinition"
	>sort ::</span
	><span class="Normal NormalText"
	> [</span
	><span class="DataType TypeConstructor"
	>Int</span
	><span class="Normal NormalText"
	>] -&gt; [</span
	><span class="DataType TypeConstructor"
	>Int</span
	><span class="Normal NormalText"
	>]</span
	><br
	 /><span class="Normal NormalText"
	>sort l | isSorted p = p </span
	><span class="Keyword"
	>where</span
	><span class="Normal NormalText"
	> p = permute l</span
	><br
	 /></code
      ></pre
    ><p
    >Sorting is usually not expressed as a search problem but let's not care for a moment and pretend we don't know better. Even if we don't know anything about sorting we can implement it using the above algorithm which reads: <em
      >to sort a list, permute it such that it is sorted</em
      >.</p
    ><p
    >Note that we have successfully split the task of sorting into two independent tasks that are easier to implement: how to permute a list and how to check whether a list is sorted.</p
    ><p
    >Lazy functional-logic programming provides the machinery to implement these tasks separately, yet execute them in a trickily interleaved way, such that the generating part (which permutes lists) produces values only to the extend demanded by the testing part (which checks whether a list is sorted).</p
    ><p
    >We can implement the tester and generator for the above sorting algorithm in Curry as follows.</p
    ><pre class="sourceCode Haskell"
    ><code
      ><span class="Function FunctionDefinition"
	>isSorted ::</span
	><span class="Normal NormalText"
	> [</span
	><span class="DataType TypeConstructor"
	>Int</span
	><span class="Normal NormalText"
	>] -&gt; </span
	><span class="DataType TypeConstructor"
	>Bool</span
	><br
	 /><span class="Normal NormalText"
	>isSorted []       = </span
	><span class="Keyword DataConstructor"
	>True</span
	><br
	 /><span class="Normal NormalText"
	>isSorted [_]      = </span
	><span class="Keyword DataConstructor"
	>True</span
	><br
	 /><span class="Normal NormalText"
	>isSorted (x:y:zs) = x &lt;= y &amp;&amp; isSorted (y:zs)</span
	><br
	 /><br
	 /><span class="Function FunctionDefinition"
	>permute ::</span
	><span class="Normal NormalText"
	> [a] -&gt; [a]</span
	><br
	 /><span class="Normal NormalText"
	>permute []     = []</span
	><br
	 /><span class="Normal NormalText"
	>permute (x:xs) = insert x (permute xs)</span
	><br
	 /><br
	 /><span class="Function FunctionDefinition"
	>insert ::</span
	><span class="Normal NormalText"
	> a -&gt; [a] -&gt; [a]</span
	><br
	 /><span class="Normal NormalText"
	>insert x xs     = x : xs</span
	><br
	 /><span class="Normal NormalText"
	>insert x (y:ys) = y : insert x ys</span
	><br
	 /></code
      ></pre
    ><p
    >In Curry the rules of a function are not matched from top to bottom (picking the first) but tried non-deterministically. Hence, <code
      >insert</code
      > can yield different non-deterministic results when applied to a non-empty list and so can <code
      >permute</code
      >.</p
    ><p
    >A more interesting observation, however, is the following: the predicate <code
      >isSorted</code
      > yields <code
      >False</code
      > if it sees two adjacent elements that are out of order <em
      >without demanding subsequent elements of the list</em
      >. The function <code
      >isSorted</code
      > can reject a permutation based on the first two elements and if it does the permutations of the remaining elements need not be computed. This contributes greately to the efficiency of the presented sorting algorithm (which has nevertheless exponential run time).</p
    ><h2 id="lazy-permutation-sort-in-haskell"
    ><a href="#TOC-lazy-permutation-sort-in-haskell"
      >lazy permutation sort in Haskell</a
      ></h2
    ><p
    >In order to model this algorithm in pure Haskell we can use the <code
      >MonadPlus</code
      > type class to express non-determinism. However, in order to maintain the laziness of the algorithm we need a data type for non-deterministic lists that can be computed on demand. More specifically, we need to be able to yield the first element of a list whose tail is yet to be computed non-deterministically.</p
    ><p
    >The <code
      >List</code
      > data type provided by this module</p
    ><pre class="sourceCode haskell"
    ><code
      ><span class="Keyword"
	>import</span
	><span class="Normal NormalText"
	> </span
	><span class="Normal ModuleName"
	>Control.Monad.Sharing.Lazy</span
	><br
	 /></code
      ></pre
    ><p
    >provides lists with nested monadic components which is exactly what we need. All we have to do is translate the Curry functions above (which use implicit non-determinism and implicit sharing) into equivalent Haskell functions that use explicit non-determinism and explicit sharing. Here we go:</p
    ><pre class="sourceCode haskell"
    ><code
      ><span class="Function FunctionDefinition"
	>sort ::</span
	><span class="Normal NormalText"
	> (MonadPlus m, Sharing m) =&gt; m (List m </span
	><span class="DataType TypeConstructor"
	>Int</span
	><span class="Normal NormalText"
	>) -&gt; m (List m </span
	><span class="DataType TypeConstructor"
	>Int</span
	><span class="Normal NormalText"
	>)</span
	><br
	 /><span class="Normal NormalText"
	>sort l = </span
	><span class="Keyword"
	>do</span
	><span class="Normal NormalText"
	> p &lt;- share (permute =&lt;&lt; l)</span
	><br
	 /><span class="Normal NormalText"
	>            </span
	><span class="Keyword DataConstructor"
	>True</span
	><span class="Normal NormalText"
	> &lt;- isSorted =&lt;&lt; p</span
	><br
	 /><span class="Normal NormalText"
	>            p</span
	><br
	 /></code
      ></pre
    ><p
    >The <code
      >sort</code
      > function uses the combinator <code
      >share</code
      > to obtain a non-deterministic permutation <code
      >p</code
      > of the list <code
      >l</code
      > which is used twice. Once as parameter to <code
      >isSorted</code
      >, once as the result of <code
      >sort</code
      >. The combinator <code
      >share</code
      > ensures that both occurrences of <code
      >p</code
      > evaluate to the same result but can still be demanded lazily, which is especially important for the first occurrence of <code
      >p</code
      >.</p
    ><p
    >The predicate <code
      >isSorted</code
      > checks whether a non-deterministic list is sorted and demands the given list only until it finds two elements out of order.</p
    ><pre class="sourceCode haskell"
    ><code
      ><span class="Function FunctionDefinition"
	>isSorted ::</span
	><span class="Normal NormalText"
	> </span
	><span class="Keyword Class"
	>Monad</span
	><span class="Normal NormalText"
	> m =&gt; List m </span
	><span class="DataType TypeConstructor"
	>Int</span
	><span class="Normal NormalText"
	> -&gt; m </span
	><span class="DataType TypeConstructor"
	>Bool</span
	><br
	 /><span class="Normal NormalText"
	>isSorted Nil           = </span
	><span class="Function"
	>return</span
	><span class="Normal NormalText"
	> </span
	><span class="Keyword DataConstructor"
	>True</span
	><br
	 /><span class="Normal NormalText"
	>isSorted (Cons mx mxs) = </span
	><span class="Keyword"
	>do</span
	><span class="Normal NormalText"
	> xs &lt;- mxs</span
	><br
	 /><span class="Normal NormalText"
	>                            </span
	><span class="Keyword"
	>case</span
	><span class="Normal NormalText"
	> xs </span
	><span class="Keyword"
	>of</span
	><br
	 /><span class="Normal NormalText"
	>                              Nil         -&gt; </span
	><span class="Function"
	>return</span
	><span class="Normal NormalText"
	> </span
	><span class="Keyword DataConstructor"
	>True</span
	><br
	 /><span class="Normal NormalText"
	>                              Cons my mys -&gt; </span
	><span class="Keyword"
	>do</span
	><span class="Normal NormalText"
	> b &lt;- liftM2 (&lt;=) mx my</span
	><br
	 /><span class="Normal NormalText"
	>                                                </span
	><span class="Keyword"
	>if</span
	><span class="Normal NormalText"
	> b </span
	><span class="Keyword"
	>then</span
	><span class="Normal NormalText"
	> isSorted =&lt;&lt; mxs</span
	><br
	 /><span class="Normal NormalText"
	>                                                     </span
	><span class="Keyword"
	>else</span
	><span class="Normal NormalText"
	> </span
	><span class="Function"
	>return</span
	><span class="Normal NormalText"
	> </span
	><span class="Keyword DataConstructor"
	>False</span
	><br
	 /></code
      ></pre
    ><p
    >The functions <code
      >permute</code
      > and <code
      >insert</code
      > are non-deterministic:</p
    ><pre class="sourceCode haskell"
    ><code
      ><span class="Function FunctionDefinition"
	>permute ::</span
	><span class="Normal NormalText"
	> MonadPlus m =&gt; List m a -&gt; m (List m a)</span
	><br
	 /><span class="Normal NormalText"
	>permute Nil           = </span
	><span class="Function"
	>return</span
	><span class="Normal NormalText"
	> Nil</span
	><br
	 /><span class="Normal NormalText"
	>permute (Cons mx mxs) = insert mx (permute =&lt;&lt; mxs)</span
	><br
	 /><br
	 /><span class="Function FunctionDefinition"
	>insert ::</span
	><span class="Normal NormalText"
	> MonadPlus m =&gt; m a -&gt; m (List m a) -&gt; m (List m a)</span
	><br
	 /><span class="Normal NormalText"
	>insert mx mxs = cons mx mxs</span
	><br
	 /><span class="Normal NormalText"
	>        </span
	><span class="Others InfixOperator"
	>`mplus`</span
	><span class="Normal NormalText"
	> </span
	><span class="Keyword"
	>do</span
	><span class="Normal NormalText"
	> Cons my mys &lt;- mxs</span
	><br
	 /><span class="Normal NormalText"
	>                   cons my (insert mx mys)</span
	><br
	 /></code
      ></pre
    ><p
    >We can now execute lazy permutation sort in Haskell.</p
    ><pre
    ><code
      >*Main&gt; evalLazy (sort (eval [(10::Int),9..1])) :: [[Int]]
[[1,2,3,4,5,6,7,8,9,10]]
</code
      ></pre
    ><p
    >The function <code
      >evalLazy</code
      > runs the computation in a lazy monad with explicit sharing and converts nested non-deterministic lists to ordinary lists. The function <code
      >eval</code
      > converts in the other direction.</p
    ><p
    >TODO: non-deterministic higher-order functions</p
    ></body
  ></html
>

